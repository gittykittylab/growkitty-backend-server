# Redis 기반 상품 랭킹 시스템 보고서

> **프로젝트 개요**  
> 기존 DB 집계 쿼리의 성능 한계를 Redis Sorted Set 기반 실시간 랭킹 시스템으로 해결
---

## 🚀 현재 시스템의 문제점

### 🔍 현재 상황
기존 시스템에선 "최근 3일간 상위 5개 상품"을 조회할 때마다 다음과 같은 무거운 쿼리가 실행됨:

```sql
SELECT p.product_id, p.product_name, p.price, SUM(oi.quantity) as sales_count
FROM order_items oi
JOIN orders o ON oi.order_id = o.order_id  
JOIN products p ON oi.product_id = p.product_id
WHERE o.order_date >= DATE_SUB(NOW(), INTERVAL 3 DAY)
GROUP BY p.product_id
ORDER BY SUM(oi.quantity) DESC
LIMIT 5;
```

### ⚠️ 주요 문제점

| 문제 영역 | 상세 내용 |
|-----------|-----------|
| **느린 응답** | 500ms ~ 2초의 긴 응답 시간 |
| **DB 부하** | 매번 수십만 건의 데이터를 스캔하는 집계 쿼리 |
| **확장성 부족** | 주문 데이터가 늘어날수록 성능이 급격히 저하 |
| **실시간성 부족** | 주문 직후에도 랭킹에 즉시 반영되지 않음 |

**💡 결론:** 이 문제를 해결하기 위해 Redis 기반의 랭킹 시스템을 도입해 보고자 함.

---

## 💡 핵심 고려사항 1: 왜 캐싱이 아닌 Redis인가?

### 🔴 캐싱의 한계점

기존 DB 쿼리 결과를 캐시에 저장하는 방식:

```java
@Cacheable(value = "topProducts", key = "'last3days'")
public List<TopProductResponse> getTopSellingProductsWithCache() {
    List<TopProductView> topProducts = topProductRepository.findAll();
    return topProducts.stream()
            .map(TopProductResponse::from)
            .collect(Collectors.toList());
}
```

#### 📌 이 방식의 문제점

1. **주기적 성능 저하**  
   캐시가 만료될 때마다 무거운 집계 쿼리를 다시 실행해야 함

2. **실시간성 부족**  
   새로운 주문이 생성되어도 랭킹에 바로 반영되지 않음

3. **병목 현상 발생 가능**  
   캐시 만료 직후 다수의 요청이 동시에 발생하면, 캐시가 아닌 DB에서 직접 조회를 수행해야 하므로 순간적으로 폭발적인 부하가 집중될 수 있음

### 🟢 Sorted Set을 선택한 이유

**Sorted Set**은 Redis의 내장 자료구조로, 각 멤버에 **점수(score)**를 부여해 실시간 정렬/집계 연산을 수행할 수 있음:

```java
// 주문 결제 처리 후 즉각적인 score 반영 가능
redisTemplate.opsForZSet().incrementScore("product_sales:today", "productId", quantity);

// 상품의 전체 조회 대신 redis의 score을 이용하여 상위 상품 key 조회 가능(필터 기능 가능)
redisTemplate.opsForZSet().reverseRange("union_key", 0, 4);
```

#### ✅ 결론

1. **실시간 집계**: Sorted Set은 단순 캐시로는 불가능한 실시간 집계·정렬을 가능하게 하여 성능과 정합성을 동시에 확보할 수 있음

2. **즉시 반영**: 주문 결제 처리 후 즉시 점수를 반영해, 무거운 집계 쿼리 반복 없이 실시간 랭킹 집계를 가능하게 함

3. **DB 부하 최소화**: 이를 통해, DB는 단순 PK 조회만 수행하므로 부하가 최소화됨

---

## 💡 핵심 고려사항 2: 왜 Redis에 모든 데이터를 넣지 않고 Redis + DB를 사용했는가?

### 초기 고민
처음에는 "모든 상품 정보를 Redis에 넣으면 더 빠르지 않을까?"라고 생각했었음:

```json
// Redis에 모든 정보 저장하는 방식
{
  "product:101": {
    "name": "아이폰 15",
    "price": 1200000,
    "stockQty": 50
  }
}
```

### 하지만 이 방식은 문제가 있음

#### 1. 데이터 동기화의 필요성 대두

```java
// 상품 가격 변경 시 Redis도 업데이트해야 함 (수동으로!)
// ❌ 만약 Redis 업데이트가 실패하면?
// ❌ 네트워크 장애로 부분 업데이트되면?
// ❌ 동시성 문제로 불일치가 발생하면?
```

**고객 불만 및 신뢰도 하락**이 발생할 수 있으며 계속해서 데이터의 일관성을 체크하고 동기화 작업을 수행해야하는 관리 포인트가 발생.

#### 2. 메모리 낭비 가능성

```
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                        Redis 올인 방식                        ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃                    Redis (고비용 메모리)                      ┃
┃ ┌─────────────────────────────────────────────────────────┐ ┃
┃ │ 🏪 상품1: 이름, 가격, 설명, 이미지... (2KB)              │ ┃
┃ │ 🏪 상품2: 이름, 가격, 설명, 이미지... (2KB)              │ ┃
┃ │ 🏪 상품3: 이름, 가격, 설명, 이미지... (2KB)              │ ┃
┃ │ ...                                                     │ ┃
┃ │ 🏪 상품100만: 이름, 가격, 설명, 이미지... (2KB)          │ ┃
┃ └─────────────────────────────────────────────────────────┘ ┃
┃                    총 메모리: 2GB (100만 × 2KB)              ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

                                🆚

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                    하이브리드 방식 (역할 분담)                 ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃          Redis (필터 역할)          ┃        DB (저장소 역할)         ┃
┃ ┌─────────────────────────────────┐ ┃ ┌─────────────────────────────┐ ┃
┃ │ 📊 상품1: 점수만 (16B)           │ ┃ │ 🏪 상품1: 전체정보 (2KB)     │ ┃
┃ │ 📊 상품2: 점수만 (16B)           │ ┃ │ 🏪 상품2: 전체정보 (2KB)     │ ┃
┃ │ 📊 상품3: 점수만 (16B)           │ ┃ │ 🏪 상품3: 전체정보 (2KB)     │ ┃
┃ │ ...                             │ ┃ │ ...                         │ ┃
┃ │ 📊 상품100만: 점수 (16B)         │ ┃ │ 🏪 상품100만: 전체정보 (2KB) │ ┃
┃ └─────────────────────────────────┘ ┃ └─────────────────────────────┘ ┃
┃         메모리: 16MB                ┃     저장공간: 2GB (저렴한 디스크)  ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
```

**비용 효율성**: Redis에 모든 상품 정보를 저장하면 고비용의 메모리를 낭비하게 됨.  
**최적화**: Redis는 점수 계산만 하고 조회는 DB에서 담당하도록 역할을 분리하면 PK를 이용한 단순 DB 조회이기 때문에 비용이 적게 들고 성능을 극대화할 수 있음.

### ✅ 결론: 하이브리드(Redis + DB) 방식을 선택

```java
public List<TopProductResponse> getTopProducts() {
    // 1. Redis: 순위 계산만 담당 (16MB)
    Set<String> topProductIds = redis.zrevrange("ranking_key", 0, 4);
    
    // 2. DB: 신뢰할 수 있는 원본 데이터 조회 (항상 최신)
    List<Product> products = productRepository.findAllById(topProductIds);
    
    return buildResponse(topProductIds, products);
}
```

#### 하이브리드(Redis + DB) 선택의 이점

| 장점 | 설명 |
|------|------|
| **데이터 일관성 보장** | DB가 Single Source of Truth 역할 |
| **메모리 효율성** | 적은 메모리 사용 |
| **개발 복잡도 감소** | 복잡한 동기화 로직 불필요 |
| **장애 복구 용이성** | Redis 장애 시에도 DB만으로 서비스 가능 |

---

## 💡 핵심 고려사항 3: TTL 만료 전략 설계

### 메모리는 유한한 자원

Redis는 In-Memory 데이터베이스로 서버의 RAM이 가득 차면 다음의 상황이 발생할 수 있음:

#### TTL 없이 계속 쌓인다면

- ❌ 메모리 부족으로 Redis 서버 다운
- ❌ 신규 데이터 저장 불가
- ❌ 전체 서비스 장애

### ⚙️ 현 시스템의 TTL 전략: 4일, 1시간

```java
// 일별 판매 데이터: 4일 후 자동 삭제
redisTemplate.expire("product_sales:2025-08-19", 4, TimeUnit.DAYS);

// 임시 집계 키: 1시간 후 자동 삭제
redisTemplate.expire("top_products:3days", 1, TimeUnit.HOURS);
```

#### 4일을 선택한 이유

| 항목 | 내용 |
|------|------|
| **비즈니스 요구사항** | 최근 3일간 랭킹 데이터 제공 필요 |
| **운영 안정성 고려** | 집계·조회 시점 차이, 지연/재처리 가능성 대비 +1일 버퍼 확보 |
| **총 보관 기간** | 4일 (3일 + 1일 여유) |

### ⚙️ 1시간 임시 키의 중요성

```java
// ZUNIONSTORE로 생성되는 임시 키
String unionKey = "top_products:3days";
redis.zunionstore(unionKey, "day1", "day2", "day3");
```

#### 🚫 만약 TTL이 없다면

- ❌ 매번 새로운 임시 키 생성
- ❌ 가비지 키들이 메모리에 누적
- ❌ 결국 메모리 누수 발생

#### ✅ 1시간 TTL의 효과

- ✅ 임시 키 자동 정리
- ✅ 메모리 누수 방지
- ✅ 안정적인 서비스 운영

---

## 📊 요약 및 결론

### 📈 성능 개선 요약

| 지표 | 기존 방식 | Redis 하이브리드 방식 | 개선 효과 |
|------|-----------|---------------------|-----------|
| **응답 속도** | 수 초 | 수십 ms | **빠른 응답** |
| **DB 부하** | 높은 집계 쿼리 부하 | 단순 조회 위주 | **안정성 확보** |
| **실시간 반영** | 불가능 | 주문 즉시 반영 | **신뢰성 향상** |
| **메모리 효율** | 전체 데이터 적재 필요 | 점수(score)만 저장 | **메모리 절감** |

### 🎯 핵심 개선 포인트

```
    1. 실시간성 확보 → 주문 발생 시 즉시 랭킹 반영
    2. DB 부하 분산 → 무거운 집계는 Redis, 상세 정보는 DB
    3. 메모리 절감 → 전체 데이터 대신 ID+점수만 보관
    4. 운영 안정성 → Redis 장애 시에도 DB로 조회 가능
```

### 💡 최종 결론
> 상위상품과 같은 통계적인 조회에 Redis는 집계·정렬을 담당하는 **필터 역할**, 
> DB는 상세 데이터 **저장소 역할**로 분리함으로써 각자의 강점을 살려 부하를 분산하고, Sorted Set 자료구조를 활용해 실시간 랭킹 반영을 가능하게 하는 것은 **성능과 안정성을 개선하면서도 효율적인 구조를 마련**할 수 있게 한다.

---