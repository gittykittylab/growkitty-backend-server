# 🧵 동시성 제어 전략 보고서

## ✅ 배경 및 개요

본 보고서는 **포인트 충전/차감**, **상품 재고 차감 및 복원**, **선착순 쿠폰 발급** 기능에서 발생할 수 있는 **동시성 문제**를 해결하기 위해 적용한 **락 전략**과 테스트 결과를 정리한 문서입니다.

각 도메인별 다음 상황을 고려하였습니다: 

- **포인트**: 금액의 처리는 사용자의 손실과 직결되며, 여러 요청이 들어오는 동시성 상황 발생 시 정합성을 고려해야 함.
- **쿠폰 발급**: 한정된 수량의 쿠폰에 대해 다수의 사용자가 동시에 발급 요청 시, 선착순 조건을 충족하며 중복 발급을 방지해야 함
- **재고 관리**: 다수 주문 요청이 동시에 발생하는 상황에서 실제 재고 수량과 DB 데이터 간 불일치를 방지하고, 초과 판매를 차단해야 함
---

## ⚠️ 문제 분석 (락 미적용 시)

### 1. **포인트 도메인 - Race Condition 발생**

**충전 테스트 결과**
```
초기 잔액: 1000
최종 잔액: 1300
예상 잔액: 1500  ❌ (200P 누락)
```

**차감 테스트 결과**
```
초기 잔액: 1000
최종 잔액: 700
예상 잔액: 500  ❌ (200P 과다 잔존)
```

**원인**: 병렬 요청이 동일한 잔액 상태를 기준으로 연산 → 일부 트랜잭션 결과가 덮어씌워짐

### 2. **쿠폰 도메인 - Race Condition 발생 및 초과 발급 문제**

```
총 요청 수: 5
발급 가능 수량: 1
성공: 3건
실패: 2건
실제 발급: 3건  ❌ (2건 초과 발급)
```

**원인**: 발급 가능 수량을 조회 후 발급하는 사이에 다른 트랜잭션이 발급 완료

### 3. **재고 도메인 - Race Condition 발생 시 차감/복원 누락**

**차감 시 문제**
```
초기 재고: 100
예상 재고: 75
실제 재고: 90  ❌ (5개 덜 차감됨)
```

**복원 시 문제**
```
감소 후 재고: 75
예상 복원 후: 100
실제 복원 후: 85  ❌ (15개 부족)
```

**원인**: 재고 감소/복원 연산 중 다른 스레드가 동일 재고 수량을 읽어 처리 → 중간 값 덮어쓰기 발생

---

## ⚙️ 단계별 해결 방법 도출 및 적용

### ✅ 1단계: 포인트 도메인 - 낙관적 락 적용

```sql
-- Entity 클래스에 @Version 어노테이션 추가
@Version
private Long version;

-- 재시도 로직 구현 (최대 5회)
@Retryable(value = {OptimisticLockingFailureException.class}, 
           maxAttempts = 5)
```

**테스트 결과 (10건 동시 요청)**
```
성공: 4건
실패: 6건
예외: Row was updated or deleted by another transaction...
초기 잔액: 1000
최종 잔액: 600 (정합성은 유지되나 실패 요청 다수)
```
> ### ⚠️ 문제 상황 발생:
>- 한 명의 유저가 동시에 여러번 포인트 충전을 요청하는 충돌 상황이 많이 발생하지 않을 것이라 생각, 성능을 고려하여 낙관적 락을 적용
>- 그러나, 테스트 결과 성공률 40%로 생각 보다 높은 확률로 포인트 충전이 되지 않았고, 정합성이 보장되지 않는다는 것을 발견 
>> → 포인트 충전이 성공할 때까지 재시도 시 DB에 대한 부하와, 포인트 도메인 특성 상 금융 가치가 있으므로 일부 요청 실패도 UX에 악영향을 줄 것을 고려하여 비관적 락으로 변경

---

### ✅ 2단계: 포인트 도메인 - 비관적 락으로 전환

```sql
-- PESSIMISTIC_WRITE 락 적용
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Point p WHERE p.userId = :userId")
Optional<Point> findByUserIdWithLock(@Param("userId") Long userId);
```

- 낙관적 락 대비 **항상 성공을 보장**하는 안정적인 처리
- 재시도 비용과 사용자 경험을 고려해 **비관적 락**을 적용

---

### ✅ 3단계: 쿠폰/재고 도메인 - 비관적 락 적용

```sql
-- 쿠폰 발급 시 비관적 락
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT c FROM Coupon c WHERE c.couponId = :couponId")
Optional<Coupon> findByCouponIdWithLock(@Param("couponId") Long couponId);

-- 재고 차감/복원 시 비관적 락
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Product p WHERE p.productId = :productId")
Optional<Product> findByProductIdWithLock(@Param("productId") Long productId);
```
- 선착순 쿠폰: 경쟁이 심하고 초과 발급을 차단할 필요 → **비관적 락** 적용 
- 재고 차감/복원: 동시에 요청이 발생할 가능성이 높으며, 재고 특성상 데이터 정합성을 최우선으로 보장해야 함. → **비관적 락** 적용
---

## 📈 실험 결과

### 💡 포인트 잔액 동시성 테스트 결과

| 시나리오 | 테스트 내용         | 초기 잔액 | 요청 수 | 성공 수 | 실패 수 | 최종 잔액 | 예상 잔액 | 결과               |
|----------|----------------|-----------|---------|---------|----------|-----------|------------|------------------|
| 1 | 포인트 충전 (락 미적용) | 0 | 5 | 3 | 2 | 300 | 500 | ❌ 실패             |
| 2 | 포인트 차감 (락 미적용) | 300 | 5 | 2 | 3 | 100 | -200 | ❌ 실패             |
| 3 | 포인트 충전 (낙관적 락) | 100 | 10 | 4 | 6 | 500 | 1100 | ⚠️ 테스트는 성공, 목표 잔액 충전 실패 |
| 4 | 포인트 차감 (낙관적 락) | 1000 | 10 | 4 | 6 | 600 | 600 | ⚠️ 테스트는 성공, 목표 잔액 차감 실패 |
| 5 | 포인트 충전 (비관적 락) | 600 | 10 | 10 | 0 | 1600 | 1600 | ✅ 성공             |
| 6 | 포인트 차감 (비관적 락) | 1000 | 10 | 10 | 0 | 0 | 0 | ✅ 성공             |

### 💡 선착순 쿠폰 도메인 테스트 결과

| 시나리오 | 전략 | 요청 수 | 성공 수 | 실패 수 | 실제 발급 수 | 결과      |
|----------|------|--------|--------|--------|-------------|---------|
| 쿠폰 발급 (락 없음) | 없음 | 5 | 3 | 2 | 3 | ❌ 초과 발급 |
| 쿠폰 발급 (비관적 락) | 비관적 락 | 5 | 1 | 4 | 1 | ✅ 정상 발급 |

### 💡 재고 도메인 테스트 결과

| 시나리오 | 전략 | 요청 수 | 최종 재고 | 예상 재고 | 결과            |
|----------|------|--------|-----------|-----------|---------------|
| 재고 차감 (락 없음) | 없음 | 5 | 90 | 75 | ❌ 목표 재고 차감 실패 |
| 재고 차감 (비관적 락) | 비관적 락 | 5 | 0 | 0 | ✅ 차감 성공       |
| 재고 복원 (락 없음) | 없음 | 5 | 85 | 100 | ❌ 목표 재고 복원 실패 |
| 재고 복원 (비관적 락) | 비관적 락 | 5 | 100 | 100 | ✅ 복원 성공       |

---

## 🎯 비관적 락 성능 분석

### 선착순 쿠폰 발급 시 성능 비교 (비관적 락 vs 락 없음)
#### ※ 쿠폰 재고가 충분한 상태에서 테스트를 진행하였습니다. 

| 구분 | 락 없음 | 비관적 락 | 성능 처리시간       |
| :--- | :--- | :--- |:--------------|
| **총 처리 시간** | 126 ms | 202 ms | `🔺 60.3% 증가` |
| **평균 처리 시간** | 101 ms | 143 ms | `🔺 41.4% 증가` |
| **최대 처리 시간**| 124 ms | 198 ms | `🔺 59.7% 증가` |
📌 **분석**
- **장점**: 쿠폰 수량이 정확히 제어되어 초과 발급이 발생하지 않음
- **단점**: 락 획득 대기 시간이 발생해 **평균 처리 시간이 약 41% 증가**
---

## ✅ 종합 평가 및 향후 과제

| 항목 | 현재 한계 | 개선 방안 |
|------|-----------|-----------|
| 성능 저하 | 비관적 락으로 인한 평균 41% 처리시간 증가 | Redis 분산락, 메시지 큐 활용 |
| 확장성 | 단일 DB 환경에서만 테스트 | Redisson, 분산락 도입 |
| 고가용성 | 락 경합 시 대기시간 발생 | 락 타임아웃, 백오프 전략 |

> - **정합성이 최우선**인 도메인(포인트, 재고, 쿠폰)에는 **비관적 락이 가장 안정성을 확보한 해결책**으로 보임.
> - **고부하 환경에서는 비관적 락 적용 시 성능 문제 및 처리 지연이 예상 됨.**
> - 향후 대규모 트래픽 환경을 고려하여 분산락 및 혼합 전략 검토 필요
